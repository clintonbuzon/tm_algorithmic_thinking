# Python 3.7.3
import time
import multiprocessing as mp
import itertools

# Function to check if a given number(n) is a prime number
def is_prime(n):
    if n == 1:
        return False
    if n < 0:
        return False
    factors = 0
    for i in range(1, n+1):
        if n % i == 0:
            factors += 1
    if factors == 2:
        return True
    return False

# Function to get maximumim number of primes for consecutive values of n, starting with n=0
# This function checks if a number is prime through brute force
# formula = n**2 + an + b
# Input: a and b used in the formula
# Output: max number of consecutive primes given a and b
def get_max_num_primes(a,b):
    for n in itertools.count(): # to infinity
        answer = (n**2) + a*n + b
        if is_prime(answer) == False:
            return n
            break

# Function to check (visually) consecutive prime numbers
# Used for debugging, or checking purposes
def check_prime_numbers(a,b):
    for n in itertools.count(): # to infinity
        answer = (n**2) + a*n +b
        print("({}**2) + {}*{} +{} = {} | is_prime: {}".format(n,a,n,b,answer,is_prime(answer)))
        if is_prime(answer) == False:
            break

# Function (brute force approach) which finds the product of the coefficients, a and b, for the quadratic expression that produces
# the maximum number of primes for consecutive values of n, starting with n = 0
# Output: elapsed_time
def brute_force_approach():
    start_time = time.time()
    print("#################################################################################")
    print("Finding solution using brute force approach")
    print("#################################################################################")

    # temporary variables holding final answer
    answer = 1 # maximum number of primes for consecutive values
    answer_a = 1
    answer_b = 1

    for a in range(-1000,1000): # |a| < 1000
        for b in range(-1000,1001): # |b| <= 1000
            max_primes = get_max_num_primes(a,b)
            if max_primes > answer:
                print("Found new max prime: {} | a= {} | b= {}".format(max_primes,a,b))
                answer = max_primes
                answer_a = a
                answer_b = b

    print("Maximum consecutive primes: {} | a: {} | b: {}".format(answer,answer_a,answer_b))
    # check_prime_numbers(answer_a,answer_b)
    print("---------------------------------------------------------------------------------")
    print("Final answer: {}*{} = {}".format(answer_a,answer_b,answer_a*answer_b))
    elapsed_time = time.time() - start_time
    print("Run time: {}".format(elapsed_time))
    print("---------------------------------------------------------------------------------")
    print()
    return elapsed_time

# Function to generate list of prime numbers using the SieveOfEratosthenes algorithm
# This significantly minimizes processing since it would just lookup from a list if n is prime or not
# Input: max  prime number
# Output: list of prime numbers starting from 2 to input(n)
def SieveOfEratosthenes(n): 
    result = []
    prime = [True for i in range(n + 1)] 
    p = 2
    while (p * p <= n): 
        if (prime[p] == True): 
            for i in range(p * 2, n + 1, p): 
                prime[i] = False
        p += 1
    prime[0]= False
    prime[1]= False
    for p in range(n + 1): 
        if prime[p]: 
            result.append(p)
    return result

# Function to get maximumim number of primes for consecutive values of n, starting with n=0
# This function checks if a number is prime by scanning a pre-generated list of prime numbers
# Input: a and b used in the formula, list of prime numbers (generated by SieveOfEratosthenes(n))
def get_max_num_primes_SieveOfEratosthenes(a,b,prime_numbers):
    for n in itertools.count():
        answer = (n**2) + a*n + b
        if answer not in prime_numbers:
            return n
            break

# Function which finds the solution using brute force but with improvement on prime number checking.
# Instead of calculating if each provided number is prime or not,
# it checks from a list of one time pre-generated prime numbers. Significantly reducing overall computation.
# Output: elapsed_time
def brute_force_approach_with_improvement_1():
    start_time = time.time()
    print("#################################################################################")
    print("Finding solution using brute force approach with improvement 1")
    print("Using pre-generated list (SieveOfEratosthenes) of prime numbers")
    print("#################################################################################")
    
    # generate list of prime numbers using SieveOfEratosthenes
    # one time processing, reduces overall computation for prime number checking
    # to be passed to function get_max_num_primes_SieveOfEratosthenes()
    prime_numbers = SieveOfEratosthenes(3000)
    
    # temporary variables holding final answer
    answer = 1 # maximum number of primes for consecutive values
    answer_a = 1
    answer_b = 1

    for a in range(-1000,1000): # |a| < 1000
        for b in range(-1000,1001): # |b| <= 1000
            max_primes = get_max_num_primes_SieveOfEratosthenes(a,b,prime_numbers) # improvement 1
            if max_primes > answer:
                print("Found new max prime: {} | a= {} | b= {}".format(max_primes,a,b))
                answer = max_primes
                answer_a = a
                answer_b = b

    print("Maximum consecutive primes: {} | a: {} | b: {}".format(answer,answer_a,answer_b))
    # check_prime_numbers(answer_a,answer_b)
    print("---------------------------------------------------------------------------------")
    print("Final answer: {}*{} = {}".format(answer_a,answer_b,answer_a*answer_b))
    elapsed_time = time.time() - start_time
    print("Run time: {}".format(elapsed_time))
    print("---------------------------------------------------------------------------------")
    return elapsed_time

# Function which finds the solution using brute force, improvement 1, and improvement on reducing values of potential parameters
# Reduction 1: 
#       if a and b are both negative, they always generate a nagative number which is never a prime number
# Reduction 2: 
#       if a and b are both even, they generate a maximum of 2 prime numbers. 
#       Since the objective is to find the max consecutive prime numbers, we can ignore these results
# Output: elapsed_time
def brute_force_approach_with_improvement_2():
    start_time = time.time()
    print("#################################################################################")
    print("Finding solution using brute force approach with improvement 1 and 2")
    print("Reducing values of potential parameters for a and b")
    print("Reduction 1: if a and b or both negative numbers")
    print("Reduction 2: if a and b or both even numbers")
    print("#################################################################################")
    
    prime_numbers = SieveOfEratosthenes(3000)
    answer = 1
    answer_a = 1
    answer_b = 1

    for a in range(-1000,1000): # |a| < 1000
        for b in range(-1000,1001): # |b| <= 1000
            if (a < 0 and b < 0) or ((a % 2) == 0 and (b % 2) == 0): # improvement 2
                continue # if meets both reduction rules, ignore this iteration and continue with next iteration. Reduces computation.
            max_primes = get_max_num_primes_SieveOfEratosthenes(a,b,prime_numbers) # improvement 1
            if max_primes > answer:
                print("Found new max prime: {} | a= {} | b= {}".format(max_primes,a,b))
                answer = max_primes
                answer_a = a
                answer_b = b

    print("Maximum consecutive primes: {} | a: {} | b: {}".format(answer,answer_a,answer_b))
    # check_prime_numbers(answer_a,answer_b)
    print("---------------------------------------------------------------------------------")
    print("Final answer: {}*{} = {}".format(answer_a,answer_b,answer_a*answer_b))
    elapsed_time = time.time() - start_time
    print("Run time: {}".format(elapsed_time))
    print("---------------------------------------------------------------------------------")
    return elapsed_time

# Function which mimics brute_force_approach_with_improvement_2() but has parameter for a_range. Removed prints.
# This function will be used for parallelism
# Input: range values for a in list form. E.g. [0,1000]
# Output: results in list format [max consecutive primes, a, b]
def worker(a_range):
    prime_numbers = SieveOfEratosthenes(3000)
    answer = 1
    answer_a = 1
    answer_b = 1
    for a in range(a_range[0],a_range[1]):
        for b in range(-1000,1001):
            if (a < 0 and b < 0) or ((a % 2) == 0 and (b % 2) == 0):
                continue
            max_primes = get_max_num_primes_SieveOfEratosthenes(a,b,prime_numbers)
            if max_primes > answer:
                answer = max_primes
                answer_a = a
                answer_b = b
    return [answer,answer_a,answer_b]

# Function which finds the solution using brute force, improvement 1 & 2, and improvement by parallelism
# Output: elapsed_time
def brute_force_approach_with_improvement_3():
    start_time = time.time()
    print("#################################################################################")
    print("Finding solution using brute force approach with improvement 1, 2, and parallelism")
    print("Running with 4 workers in parallel")
    print("#################################################################################")
    args_list = [[-1000,-500],[-500,0],[0,500],[500,1000]] #parameters to be passed to workers
    pool = mp.Pool(processes=4)
    results = [pool.apply_async(worker, args=(x,)) for x in args_list]
    output = [p.get() for p in results]
    
    answer = 1
    answer_a = 1
    answer_b = 1

    # scan through outputs of the workers and capture worker results with highest max primes
    for i in range(0,4):
        print("Worker {} | Max prime: {} | a= {} | b= {}".format(i+1,output[i][0],output[i][1],output[i][2]))
        if output[i][0] > answer:
            answer = output[i][0]
            answer_a = output[i][1]
            answer_b = output[i][2]

    print("---------------------------------------------------------------------------------")
    print("Maximum consecutive primes: {} | a: {} | b: {}".format(answer,answer_a,answer_b))
    #check_prime_numbers(answer_a,answer_b)
    print("---------------------------------------------------------------------------------")
    print("Final answer: {}*{} = {}".format(answer_a,answer_b,answer_a*answer_b))
    elapsed_time = time.time() - start_time
    print("Run time: {}".format(elapsed_time))
    print("---------------------------------------------------------------------------------")
    return elapsed_time

# Improved is_prime() function
# Instead of scanning through range(1,n+1), iterate from 2 to sqrt(N) to find all the factors of n
def is_prime_v2(n):
    if n == 1:
        return False
    if n < 0:
        return False
    i = 2
    while i*i <= n:
        if n % i == 0:
            return False
        i += 1
    return True

# Improved get_max_num_primes() using is_prime_v2()
def get_max_num_primes_v2(a,b):
    for n in itertools.count(): # to infinity
        answer = (n**2) + a*n + b
        if is_prime_v2(answer) == False:
            return n
            break

# Improved worker() using get_max_num_primes_v2()
def worker_v2(a_range):
    answer = 1
    answer_a = 1
    answer_b = 1
    for a in range(a_range[0],a_range[1]):
        for b in range(-1000,1001):
            if (a < 0 and b < 0) or ((a % 2) == 0 and (b % 2) == 0):
                continue
            max_primes = get_max_num_primes_v2(a,b)
            if max_primes > answer:
                answer = max_primes
                answer_a = a
                answer_b = b
    return [answer,answer_a,answer_b]

# Function which finds the solution using brute force, improvement 2, 3, and better prime checking (is_prime_v2)
# is_prime_v2() is faster than SieveOfEratosthenes approach thus we use this instead
# Output: elapsed_time
def brute_force_approach_with_improvement_4():
    start_time = time.time()
    print("#################################################################################")
    print("Finding solution using brute force approach")
    print("with improvement 2, 3, and faster is_prime (is_prime_v2)")
    print("Running with 4 workers in parallel")
    print("#################################################################################")
    args_list = [[-1000,-500],[-500,0],[0,500],[500,1000]] #parameters to be passed to workers
    pool = mp.Pool(processes=4)
    results = [pool.apply_async(worker_v2, args=(x,)) for x in args_list] #use worker_v2 
    output = [p.get() for p in results]
    
    answer = 1
    answer_a = 1
    answer_b = 1

    # scan through outputs of the workers and capture worker results with highest max primes
    for i in range(0,4):
        print("Worker {} | Max prime: {} | a= {} | b= {}".format(i+1,output[i][0],output[i][1],output[i][2]))
        if output[i][0] > answer:
            answer = output[i][0]
            answer_a = output[i][1]
            answer_b = output[i][2]

    print("---------------------------------------------------------------------------------")
    print("Maximum consecutive primes: {} | a: {} | b: {}".format(answer,answer_a,answer_b))
    #check_prime_numbers(answer_a,answer_b)
    print("---------------------------------------------------------------------------------")
    print("Final answer: {}*{} = {}".format(answer_a,answer_b,answer_a*answer_b))
    elapsed_time = time.time() - start_time
    print("Run time: {}".format(elapsed_time))
    print("---------------------------------------------------------------------------------")
    return elapsed_time

# main
if __name__ == '__main__':

    runtime_brute_force = brute_force_approach()
    
    runtime_improvement_1 = brute_force_approach_with_improvement_1()
    print("Faster than brute force approach by: {} seconds".format(runtime_brute_force - runtime_improvement_1))
    print("---------------------------------------------------------------------------------")
    print()
    
    runtime_improvement_2 = brute_force_approach_with_improvement_2()
    print("Faster than brute force approach by: {} seconds".format(runtime_brute_force - runtime_improvement_2))
    print("Faster than improvement 1 by       : {} seconds".format(runtime_improvement_1 - runtime_improvement_2))
    print("---------------------------------------------------------------------------------")
    print()

    runtime_improvement_3 = brute_force_approach_with_improvement_3()
    print("Faster than brute force approach by: {} seconds".format(runtime_brute_force - runtime_improvement_3))
    print("Faster than improvement 1 by       : {} seconds".format(runtime_improvement_1 - runtime_improvement_3))
    print("Faster than improvement 1 and 2 by : {} seconds".format(runtime_improvement_2 - runtime_improvement_3))
    print("---------------------------------------------------------------------------------")
    print()

    runtime_improvement_4 = brute_force_approach_with_improvement_4()
    print("Faster than brute force approach by  : {} seconds".format(runtime_brute_force - runtime_improvement_4))
    print("Faster than improvement 1 by         : {} seconds".format(runtime_improvement_1 - runtime_improvement_4))
    print("Faster than improvement 1 and 2 by   : {} seconds".format(runtime_improvement_2 - runtime_improvement_4))
    print("Faster than improvement 1, 2 and 3 by: {} seconds".format(runtime_improvement_3 - runtime_improvement_4))
    print("---------------------------------------------------------------------------------")
    print()

    print("#################################################################################")
    print("Summary of run times:")
    print("#################################################################################")
    print("runtime_brute_force  : {}".format(runtime_brute_force))
    print("runtime_improvement_1: {}".format(runtime_improvement_1))
    print("runtime_improvement_2: {}".format(runtime_improvement_2))
    print("runtime_improvement_3: {}".format(runtime_improvement_3))
    print("runtime_improvement_4: {}".format(runtime_improvement_4))
    print("---------------------------------------------------------------------------------")
    